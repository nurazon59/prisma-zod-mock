# Usage in Tests

Examples of using mock data with Jest and Vitest.

## Jest Setup

### Basic Test Structure

```typescript filename="user.service.test.ts"
import { createUserMock, UserSchema } from './generated';
import { UserService } from './user.service';
import { PrismaClient } from '@prisma/client';

// Mock Prisma Client
jest.mock('@prisma/client');

describe('UserService', () => {
  let userService: UserService;
  let prisma: jest.Mocked<PrismaClient>;

  beforeEach(() => {
    prisma = new PrismaClient() as jest.Mocked<PrismaClient>;
    userService = new UserService(prisma);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createUser', () => {
    it('should create a new user', async () => {
      const mockUser = createUserMock();
      prisma.user.create = jest.fn().mockResolvedValue(mockUser);

      const result = await userService.createUser({
        email: mockUser.email,
        name: mockUser.name,
      });

      expect(prisma.user.create).toHaveBeenCalledWith({
        data: {
          email: mockUser.email,
          name: mockUser.name,
        },
      });
      expect(result).toEqual(mockUser);
    });

    it('should validate user data', async () => {
      const invalidData = { email: 'invalid-email' };

      await expect(userService.createUser(invalidData)).rejects.toThrow();
    });
  });

  describe('getUserById', () => {
    it('should return user when found', async () => {
      const mockUser = createUserMock();
      prisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);

      const result = await userService.getUserById(mockUser.id);

      expect(prisma.user.findUnique).toHaveBeenCalledWith({
        where: { id: mockUser.id },
      });
      expect(result).toEqual(mockUser);
    });

    it('should throw when user not found', async () => {
      prisma.user.findUnique = jest.fn().mockResolvedValue(null);

      await expect(userService.getUserById('non-existent-id')).rejects.toThrow('User not found');
    });
  });
});
```

## Vitest Setup

### Configuration

```typescript filename="vitest.config.ts"
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./test/setup.ts'],
  },
});
```

### Test Setup File

```typescript filename="test/setup.ts"
import { beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

beforeAll(async () => {
  // Setup test database
  await prisma.$connect();
});

afterAll(async () => {
  await prisma.$disconnect();
});

beforeEach(async () => {
  // Clear database before each test
  const tables = ['User', 'Post', 'Comment'];
  for (const table of tables) {
    await prisma.$executeRawUnsafe(`TRUNCATE TABLE "${table}" CASCADE`);
  }
});
```

### Integration Tests

```typescript filename="integration.test.ts"
import { describe, it, expect } from 'vitest';
import { PrismaClient } from '@prisma/client';
import { createUserMock, createPostMock, createCommentMock } from './generated';

const prisma = new PrismaClient();

describe('Blog Integration Tests', () => {
  it('should create user with posts and comments', async () => {
    // Create test data
    const userData = createUserMock();
    const user = await prisma.user.create({ data: userData });

    const postData = createPostMock({ authorId: user.id });
    const post = await prisma.post.create({ data: postData });

    const commentData = createCommentMock({
      authorId: user.id,
      postId: post.id,
    });
    const comment = await prisma.comment.create({ data: commentData });

    // Verify relationships
    const userWithRelations = await prisma.user.findUnique({
      where: { id: user.id },
      include: {
        posts: true,
        comments: true,
      },
    });

    expect(userWithRelations?.posts).toHaveLength(1);
    expect(userWithRelations?.comments).toHaveLength(1);
    expect(userWithRelations?.posts[0].id).toBe(post.id);
  });

  it('should handle complex queries', async () => {
    // Create multiple users with posts
    const users = await Promise.all(
      Array.from({ length: 5 }).map(async () => {
        const user = await prisma.user.create({
          data: createUserMock(),
        });

        await Promise.all(
          Array.from({ length: 3 }).map(() =>
            prisma.post.create({
              data: createPostMock({
                authorId: user.id,
                status: 'published',
              }),
            })
          )
        );

        return user;
      })
    );

    // Query published posts
    const publishedPosts = await prisma.post.findMany({
      where: { status: 'published' },
      include: { author: true },
    });

    expect(publishedPosts).toHaveLength(15);
    expect(publishedPosts[0].author).toBeDefined();
  });
});
```

## Testing Best Practices

### Factory Functions

```typescript filename="test-factories.ts"
import { createUserMock, createPostMock, createCommentMock } from './generated';

// Create factory functions with common test scenarios
export const factories = {
  user: {
    admin: () =>
      createUserMock({
        email: 'admin@test.com',
        role: 'admin',
      }),
    regular: () =>
      createUserMock({
        role: 'user',
      }),
    withPosts: async (postCount = 3) => {
      const user = createUserMock();
      const posts = Array.from({ length: postCount }).map(() =>
        createPostMock({ authorId: user.id })
      );
      return { user, posts };
    },
  },

  post: {
    draft: (authorId: string) =>
      createPostMock({
        authorId,
        status: 'draft',
      }),
    published: (authorId: string) =>
      createPostMock({
        authorId,
        status: 'published',
        publishedAt: new Date(),
      }),
    withComments: (authorId: string, commentCount = 5) => {
      const post = createPostMock({ authorId });
      const comments = Array.from({ length: commentCount }).map(() =>
        createCommentMock({
          postId: post.id,
          authorId: createUserMock().id,
        })
      );
      return { post, comments };
    },
  },
};
```

### Snapshot Testing

```typescript filename="snapshot.test.ts"
import { describe, it, expect } from 'vitest';
import { createUserMock, createPostMock } from './generated';

describe('Data Snapshots', () => {
  it('should match user data structure', () => {
    const user = createUserMock({
      email: 'snapshot@test.com',
      name: 'Test User',
    });

    expect(user).toMatchSnapshot({
      id: expect.any(String),
      createdAt: expect.any(Date),
      updatedAt: expect.any(Date),
    });
  });

  it('should match post with relations', () => {
    const author = createUserMock();
    const post = createPostMock({
      authorId: author.id,
      author,
    });

    expect(post).toMatchSnapshot({
      id: expect.any(String),
      createdAt: expect.any(Date),
      updatedAt: expect.any(Date),
      publishedAt: expect.any(Date),
      author: {
        id: expect.any(String),
        createdAt: expect.any(Date),
        updatedAt: expect.any(Date),
      },
    });
  });
});
```

### Test Utilities

```typescript filename="test-utils.ts"
import { PrismaClient } from '@prisma/client';
import { createUserMock, createPostMock } from './generated';

export class TestDatabase {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async seedTestData() {
    // Create consistent test data
    const users = await Promise.all([
      this.prisma.user.create({
        data: createUserMock({ email: 'user1@test.com' }),
      }),
      this.prisma.user.create({
        data: createUserMock({ email: 'user2@test.com' }),
      }),
    ]);

    const posts = await Promise.all(
      users.flatMap((user) =>
        Array.from({ length: 2 }).map(() =>
          this.prisma.post.create({
            data: createPostMock({ authorId: user.id }),
          })
        )
      )
    );

    return { users, posts };
  }

  async cleanup() {
    const tables = ['Comment', 'Post', 'User'];
    for (const table of tables) {
      await this.prisma.$executeRawUnsafe(`TRUNCATE TABLE "${table}" CASCADE`);
    }
  }

  async disconnect() {
    await this.prisma.$disconnect();
  }
}

// Usage in tests
const testDb = new TestDatabase();

beforeEach(async () => {
  await testDb.cleanup();
});

afterAll(async () => {
  await testDb.disconnect();
});
```
