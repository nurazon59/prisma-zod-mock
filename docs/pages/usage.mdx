# 使い方

## 基本的な使用方法

### モックデータの生成

生成されたモックファクトリーを使用して、型安全なテストデータを作成できます。

```typescript filename="example.ts"
import { createUserMock, createPostMock } from './generated';

// 単一のユーザーモックを生成
const user = createUserMock();
console.log(user);
// {
//   id: 'clh3k4n5j0000qw8w5h3k4n5j',
//   email: 'tanaka.taro@example.com',
//   name: '田中 太郎',
//   createdAt: 2024-01-15T10:30:00.000Z
// }

// カスタムデータでモックを生成
const customUser = createUserMock({
  name: '山田 花子',
  email: 'yamada@example.com',
});
```

### バッチ生成

複数のモックデータを一度に生成できます。

```typescript
import { createUserMockBatch } from './generated';

// 10人のユーザーを生成
const users = createUserMockBatch(10);

// カスタムデータを含む5人のユーザーを生成
const customUsers = createUserMockBatch(5, {
  role: 'ADMIN',
});
```

### Zodスキーマによるバリデーション

生成されたZodスキーマを使用してデータをバリデートできます。

```typescript
import { UserSchema } from './generated';

const userData = {
  id: 'test-id',
  email: 'test@example.com',
  name: 'Test User',
  createdAt: new Date(),
};

// バリデーション
const validatedUser = UserSchema.parse(userData);

// 安全なパース（エラーをスローしない）
const result = UserSchema.safeParse(userData);
if (result.success) {
  console.log('Valid user:', result.data);
} else {
  console.error('Validation errors:', result.error);
}
```

## リレーションを含むデータ

### 基本的なリレーション

```typescript
// ユーザーと投稿を含むモックデータ
const userWithPosts = createUserMock({
  posts: createPostMockBatch(3),
});

// または、createRelationMocksオプションが有効な場合
const userWithRelations = createUserWithRelationsMock();
```

### ネストしたリレーション

```typescript
// 深いリレーションを含むデータ
const post = createPostMock({
  author: createUserMock({
    profile: createProfileMock(),
  }),
  comments: createCommentMockBatch(5),
});
```

## テストでの使用

### Jest/Vitestでの例

```typescript filename="user.test.ts"
import { describe, it, expect } from 'vitest';
import { createUserMock, UserSchema } from './generated';
import { createUser } from './user-service';

describe('User Service', () => {
  it('should create a valid user', async () => {
    const mockUser = createUserMock();
    
    const result = await createUser(mockUser);
    
    expect(result).toBeDefined();
    expect(UserSchema.parse(result)).toEqual(result);
  });
  
  it('should handle batch operations', async () => {
    const mockUsers = createUserMockBatch(10);
    
    const results = await Promise.all(
      mockUsers.map(user => createUser(user))
    );
    
    expect(results).toHaveLength(10);
  });
});
```

### Storybookでの使用

```typescript filename="UserProfile.stories.ts"
import type { Meta, StoryObj } from '@storybook/react';
import { UserProfile } from './UserProfile';
import { createUserMock } from './generated';

const meta: Meta<typeof UserProfile> = {
  title: 'Components/UserProfile',
  component: UserProfile,
};

export default meta;

type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    user: createUserMock(),
  },
};

export const WithLongName: Story = {
  args: {
    user: createUserMock({
      name: '非常に長い名前を持つユーザーのテストケース',
    }),
  },
};
```

## APIモックでの使用

### MSWでの例

```typescript filename="mocks/handlers.ts"
import { rest } from 'msw';
import { createUserMock, createPostMockBatch } from './generated';

export const handlers = [
  rest.get('/api/users/:id', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json(createUserMock({ id: req.params.id }))
    );
  }),
  
  rest.get('/api/posts', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json(createPostMockBatch(20))
    );
  }),
];
```

## ベストプラクティス

### 1. シードデータの一貫性

テストで一貫性のあるデータが必要な場合は、シード値を使用します：

```typescript
import { faker } from '@faker-js/faker';

// シード値を設定して一貫性のあるデータを生成
faker.seed(123);

const user1 = createUserMock(); // 常に同じデータ
const user2 = createUserMock(); // 常に同じデータ
```

### 2. ファクトリー関数のカスタマイズ

共通のテストデータパターンがある場合は、カスタムファクトリーを作成します：

```typescript filename="test-factories.ts"
import { createUserMock, createPostMock } from './generated';

export const createAdminUser = (overrides = {}) => {
  return createUserMock({
    role: 'ADMIN',
    isActive: true,
    ...overrides,
  });
};

export const createPublishedPost = (overrides = {}) => {
  return createPostMock({
    published: true,
    publishedAt: new Date(),
    ...overrides,
  });
};
```

### 3. 型の再利用

生成された型を活用してテストを型安全に保ちます：

```typescript
import type { User, Post } from '@prisma/client';
import { createUserMock } from './generated';

function processUser(user: User): void {
  // ユーザー処理ロジック
}

// 型安全なモックデータ
const mockUser: User = createUserMock();
processUser(mockUser);
```